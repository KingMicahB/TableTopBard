# Song History Implementation Plan

## Overview
Implement a history feature to store, retrieve, and manage previously generated songs. This will allow users to access their past music generations and add them to the current playlist.

## Storage Options Analysis

### Option 1: Suno API Query (User's Suggestion)
**Pros:**
- No additional storage needed
- Songs are already stored on Suno's servers
- Always up-to-date with what's available on Suno

**Cons:**
- Requires Suno API to have a "list all songs" endpoint
- May not include metadata we need (scene name, generation parameters)
- Dependent on Suno API availability
- May include songs not generated by this app

**Implementation:**
- Check if Suno API has `/api/v1/songs` or similar endpoint
- Query on app load or when history panel is opened
- Cache results locally to reduce API calls

### Option 2: Local Storage (Frontend Only)
**Pros:**
- Simple, no backend changes
- Fast access
- Works offline

**Cons:**
- Limited storage space (~5-10MB)
- Not shared across devices
- Lost if browser data is cleared
- No server-side backup

**Implementation:**
- Store song metadata in `localStorage` when songs are generated
- Retrieve on app load
- Simple JSON structure

### Option 3: Backend File-Based Storage (JSON)
**Pros:**
- Simple to implement
- No database setup required
- Persistent across sessions
- Easy to backup

**Cons:**
- Not scalable for large datasets
- File locking issues with concurrent writes
- No query capabilities
- Manual cleanup needed

**Implementation:**
- Store songs in `backend/data/songs.json`
- Read/write on each operation
- Include metadata: id, title, sceneName, audioUrl, imageUrl, createdAt, generationParams

### Option 4: Backend Database (SQLite)
**Pros:**
- Proper database with query capabilities
- Scalable
- Can add indexes, search, filtering
- ACID transactions
- Easy to migrate to PostgreSQL later

**Cons:**
- Requires database setup
- Slightly more complex
- Need migration scripts

**Implementation:**
- Use `better-sqlite3` or `sql.js` for SQLite
- Create `songs` table with metadata
- RESTful API endpoints for CRUD operations

## Recommended Approach: Hybrid (Option 1 + Option 4)

**Primary:** Backend SQLite database for reliable, queryable storage
**Secondary:** Suno API query as a fallback/sync mechanism

This gives us:
- Reliable local storage with metadata
- Ability to sync with Suno if needed
- Fast queries and filtering
- Room to grow

## Implementation Plan

### Phase 1: Backend Storage Setup

#### 1.1 Database Schema
```sql
CREATE TABLE songs (
  id TEXT PRIMARY KEY,
  suno_id TEXT UNIQUE,           -- Suno's song ID
  title TEXT NOT NULL,
  scene_name TEXT,               -- Extracted scene name
  audio_url TEXT NOT NULL,
  image_url TEXT,
  prompt TEXT,                    -- Music generation prompt used
  generation_params TEXT,         -- JSON: model, instrumental, style, etc.
  created_at INTEGER NOT NULL,   -- Unix timestamp
  updated_at INTEGER NOT NULL
);

CREATE INDEX idx_created_at ON songs(created_at DESC);
CREATE INDEX idx_scene_name ON songs(scene_name);
```

#### 1.2 Backend Service: `backend/src/services/songHistory.js`
- `saveSong(songData)` - Save song to database after generation
- `getAllSongs(limit, offset)` - Retrieve songs with pagination
- `getSongById(id)` - Get single song
- `deleteSong(id)` - Remove song from history
- `searchSongs(query)` - Search by title/scene name

#### 1.3 Backend Routes: `backend/src/routes/history.js`
- `GET /api/history` - Get all songs (with pagination)
- `GET /api/history/:id` - Get single song
- `DELETE /api/history/:id` - Delete song
- `GET /api/history/search?q=...` - Search songs

#### 1.4 Update Music Generation Flow
- After successful music generation, automatically save to history
- Update `backend/src/routes/audio.js` to call `saveSong()` after polling completes

### Phase 2: Suno API Integration (Optional)

#### 2.1 Check Suno API Endpoints
- Research if Suno has a "list songs" endpoint
- If available, create `syncWithSuno()` function
- Periodically sync to catch any songs generated outside the app

#### 2.2 Service: `backend/src/services/sunoSync.js`
- `getSunoSongs()` - Query Suno API for all songs
- `syncSongs()` - Compare and merge with local database

### Phase 3: Frontend Implementation

#### 3.1 API Client: `Front-end-prod2/lib/api.ts`
Add functions:
- `getSongHistory(limit?, offset?)`
- `getSongById(id)`
- `deleteSong(id)`
- `searchSongs(query)`

#### 3.2 History Component: `Front-end-prod2/components/music/song-history.tsx`
Features:
- List view of all songs (cards or table)
- Search/filter by title or scene name
- Sort by date (newest/oldest)
- Click to add to playlist
- Delete button for each song
- Pagination or infinite scroll
- Empty state when no history

#### 3.3 Integration with Music Player
- "Add to Playlist" button on each history item
- "Load History" button in music player
- Merge history songs with current playlist

#### 3.4 Main Page Updates: `Front-end-prod2/app/page.tsx`
- Add history state management
- Load history on app mount
- Pass history to music player
- Auto-save new songs to history

### Phase 4: UI/UX Enhancements

#### 4.1 History Panel Design
- Collapsible panel (similar to settings)
- Grid or list view toggle
- Song cards with:
  - Thumbnail (if available)
  - Title
  - Scene name
  - Date generated
  - Duration (if available)
  - Quick actions (play, add to playlist, delete)

#### 4.2 Search & Filter
- Search bar at top
- Filter by scene name
- Sort options (date, title, scene)

#### 4.3 Empty States
- "No songs yet" message
- Link to generate first song

## Technical Details

### Database Library Choice
**Recommendation: `better-sqlite3`**
- Synchronous API (simpler for this use case)
- Fast and reliable
- No async overhead for simple operations
- Easy to migrate to async later if needed

### Data Flow
```
1. User generates music
   ↓
2. Suno API returns song data
   ↓
3. Backend saves to SQLite database
   ↓
4. Frontend receives song data
   ↓
5. Frontend adds to playlist AND saves to history state
   ↓
6. History panel displays from database on load
```

### Song Data Structure
```typescript
interface SongHistory {
  id: string                    // Our internal ID
  sunoId?: string              // Suno's song ID (if available)
  title: string
  sceneName?: string
  audioUrl: string
  imageUrl?: string
  prompt?: string
  generationParams?: {
    model: string
    instrumental: boolean
    customMode: boolean
    style?: string
  }
  createdAt: number            // Unix timestamp
  updatedAt: number
}
```

## Implementation Steps

1. **Install dependencies**
   ```bash
   cd backend
   npm install better-sqlite3
   ```

2. **Create database setup**
   - `backend/src/services/database.js` - Database initialization
   - `backend/src/migrations/001_create_songs_table.sql` - Schema

3. **Implement song history service**
   - `backend/src/services/songHistory.js`

4. **Create API routes**
   - `backend/src/routes/history.js`
   - Add to `backend/src/server.js`

5. **Update music generation flow**
   - Modify `backend/src/routes/audio.js` to save after generation

6. **Frontend API client**
   - Add history functions to `Front-end-prod2/lib/api.ts`

7. **Create history component**
   - `Front-end-prod2/components/music/song-history.tsx`

8. **Integrate with main page**
   - Add history state and UI

9. **Test and refine**
   - Test saving, loading, searching, deleting
   - Handle edge cases (duplicate songs, missing data)

## Future Enhancements

- Export history to JSON/CSV
- Import songs from other sources
- Playlist management (save/load playlists)
- Song tags/categories
- Favorite songs
- Share songs with others
- Cloud sync (if multi-device support needed)

## Questions to Resolve

1. **Does Suno API have a "list all songs" endpoint?**
   - Need to check their documentation
   - If yes, we can use it for syncing
   - If no, we rely entirely on our database

2. **Should we store audio files locally?**
   - Currently using Suno's URLs
   - Consider: What if Suno URLs expire?
   - Option: Download and store locally (requires more storage)

3. **How long should history be kept?**
   - Unlimited?
   - Configurable limit?
   - Auto-cleanup after X days?

4. **Should history be user-specific?**
   - Currently single-user app
   - If multi-user later, add `user_id` column

## Estimated Implementation Time

- Phase 1 (Backend): 2-3 hours
- Phase 2 (Suno Sync): 1-2 hours (if endpoint exists)
- Phase 3 (Frontend): 3-4 hours
- Phase 4 (UI/UX): 2-3 hours
- Testing & Refinement: 1-2 hours

**Total: ~9-14 hours**
